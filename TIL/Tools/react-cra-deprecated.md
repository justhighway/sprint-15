# R.I.P. CRA: 리액트와 CRA, 영광과 쇠락

## 1. 프론트엔드 개발의 패러다임 혁신

프론트엔드 개발은 과거 몇 년 동안 급격하게 변화해왔습니다. 초기의 웹 애플리케이션은 서버-사이드 렌더링(SSR) 방식을 사용하여 HTML을 서버에서 미리 렌더링한 후 클라이언트에게 전달하는 방식을 주로 사용했습니다. 지금도 자주 쓰이는 PHP와 JQuery가 그렇습니다.

과거 SSR은 사용자 경험과 성능 측면에서 한계가 있었습니다. 동적 페이지와 상호작용을 원활하게 구현하려면 매번 서버로 요청을 보내야 했는데, 이 때문에 페이지 전환 시 매번 전체 페이지 리로드가 발생하게 되었습니다.

**싱글 페이지 애플리케이션(SPA)**의 등장으로 웹 애플리케이션은 전혀 다른 방향으로 진화하기 시작했습니다. SPA는 초기 로딩 후 서버와의 최소한의 데이터 통신을 통해 페이지 내에서 동적인 콘텐츠 업데이트가 가능해졌습니다. 사용자의 인터랙티브한 경험을 개선하고, 웹 애플리케이션의 반응성을 극대화할 수 있는 기회를 제공했습니다.

하지만 SPA가 가져온 혁신은 그 자체로 새로운 문제를 야기했습니다. 상태 관리와 효율적인 렌더링이 필수적인 문제로 떠올랐는데, 여기서 등장한 것이 바로 **리액트(React)**입니다.

## 2. 리액트의 등장

2013년, 페이스북은 리액트라는 라이브러리를 공개하며 웹 애플리케이션의 패러다임을 변화시켰습니다. 리액트는 **가상 DOM(Virtual DOM)**을 사용하여 상태 변화에 따른 UI 업데이트를 효율적으로 처리할 수 있게 해주었습니다.

또한 리액트는 컴포넌트 기반 아키텍처를 채택하여 UI를 작은 재사용 가능한 단위로 나누어 관리할 수 있게 했습니다. 이는 코드의 모듈화와 재사용성을 극대화하여 대규모 애플리케이션의 관리 및 유지보수를 훨씬 용이하게 만들었습니다.

하지만 리액트가 가져온 변화는 단순히 라이브러리의 차원이 아니었습니다. 리액트의 컴포넌트 기반 개발은 개발 방식 자체에 근본적인 변화를 가져왔습니다. 이제 애플리케이션은 **상태(state)**와 **속성(props)**에 따라 UI를 렌더링하는 단위인 컴포넌트로 구성되며, 이로 인해 UI의 추상화와 구성 요소의 분리가 더욱 강조되었습니다. 단방향 데이터 흐름(one-way data flow)은 상태 관리와 데이터 흐름의 예측 가능성을 높이며, 복잡한 애플리케이션을 보다 직관적으로 설계할 수 있도록 도와주었습니다.

## 3. 리액트를 쉽게 시작할 수 있게 만든 create-react-app

리액트의 혁신적인 특징에도 불구하고, 리액트를 처음 접하는 개발자들에게는 여전히 복잡한 설정이 문제였습니다.

초기 리액트 애플리케이션을 시작하려면, 개발자는 Babel, Webpack, ESLint와 같은 여러 도구들을 수동으로 설정해야 했고, 이는 초보자에게 큰 장벽이었습니다. 리액트의 발전을 가속화하려는 요구에 따라, **Create React App(CRA)**가 2016년에 등장했습니다.

CRA는 리액트 프로젝트를 설정하는 복잡한 작업을 자동화하고, 빠르게 리액트를 시작할 수 있도록 도와주었습니다. 하나의 명령어로 리액트 애플리케이션을 설정하고, 기본적인 개발 환경을 제공함으로써 개발자들은 더 이상 환경 설정에 신경 쓰지 않고 애플리케이션 개발에만 집중할 수 있었습니다. CRA는 리액트를 처음 접하는 개발자들에게 리액트의 진입 장벽을 낮추고 리액트 커뮤니티의 성장을 이끄는 중요한 역할을 했습니다.

```zsh
npx create-react-app my-app
cd my-app
npm start
```

위 명령어 하나로 **Babel**, **Webpack**, **Jest**와 같은 도구들이 자동으로 설정되어 개발자는 리액트의 개발에만 집중할 수 있었습니다.

## 4. 프론트엔드 도구의 발전에 따른 도전

`create-react-app` (CRA)은 리액트 생태계에서 초기 단계의 큰 혁신을 일으킨 도구였지만, 시간이 지나면서 다양한 제약과 한계가 드러났습니다.

프론트엔드 개발의 복잡도와 기술적 요구가 급격히 변화하면서 점차 빌드 성능, 커스터마이징의 어려움, 모던 애플리케이션 요구에 대한 대응 부족이 주요한 문제로 드러났습니다.

### 1) 느린 빌드 속도와 성능 문제

CRA가 초기 리액트 생태계에서 유용하게 사용되었던 주된 이유는 빠르게 프로젝트를 시작할 수 있는 편리함과 함께, Webpack을 사용하여 애플리케이션을 번들링하는 방식이었습니다.

Webpack은 애플리케이션을 번들링하는 데 있어 매우 강력한 도구였으며, 개발 환경을 설정하는 데 있어 고도의 유연성을 제공했습니다. 그러나 프로젝트가 커질수록 빌드 시간과 초기 로딩 속도가 급격히 느려지는 문제가 발생했습니다. 이는 Webpack의 복잡한 번들링 및 트랜스파일링 과정에서 발생하는 비효율성에 기인한 문제입니다.

Webpack은 내부적으로 **의존성 트리를 분석**하고 **파일을 분할**하며 **트랜스파일링** 과정을 거칩니다. 이 과정은 복잡한 사전 설정을 요구하며, **소스 코드가 커지고 복잡해질수록** 더 많은 시간과 리소스를 소비하게 됩니다. 특히, **HMR(Hot Module Replacement)**이나 빠른 개발 서버 반응 속도를 보장하기 위해 여러 최적화 기법을 추가해도, 애플리케이션이 커질수록 빌드 속도는 급격히 저하되었습니다. 특히 대규모 애플리케이션에서는 번들 크기가 커지고, 중복된 코드와 **느린 트리 쉐이킹(tree-shaking)**으로 인한 성능 저하가 더 두드러졌습니다.

이를 해결하려는 시도가 있었지만, **Webpack**의 **복잡성**과 **확장성** 문제는 여전히 **효율적인 빌드 처리**를 가로막고 있었으며, 이는 개발자들에게 실질적인 피로감을 안겨주었습니다.

### 2) 커스터마이징의 어려움

CRA의 또 다른 문제점은 커스터마이징의 어려움이었습니다. CRA는 기본적으로 최소한의 개발 환경과 설정만을 제공했습니다. 프로젝트가 커지고 특정 요구 사항에 맞게 커스터마이징이 필요하면 `eject`라는 명령어를 사용하여 환경 설정을 수정할 수 있도록 했습니다.

하지만 `eject` 이후에는 CRA가 제공하는 기본 설정에서 벗어나게 되어, **Webpack**, **Babel**, **ESLint** 등의 도구를 직접 관리해야 하는 상황에 직면하게 됩니다. 이로 인해 모든 설정을 관리해야 하는 부담과 함께, 협업 시 환경 차이로 인한 문제도 발생할 수 있었습니다. 업데이트와 유지보수가 더 어려워지는 바람에, 새로운 기능을 도입하거나 성능 최적화를 진행할 때의 유연성이 현저히 떨어졌습니다.

이 문제는 특히 팀 규모가 커지거나 프로젝트가 복잡해지면서 더욱 심각해졌습니다. CRA는 `eject`하지 않으면 기본 설정에 의존하다 보니, 특정 요구에 맞게 세밀한 조정을 해야 할 경우 개발 속도와 협업 효율성이 크게 저하되었고, 이는 개발자의 생산성을 감소시키는 요인이 되었습니다.

### 3) 모던 웹 애플리케이션의 발전에 대한 대응 부족

CRA는 기본적으로 **클라이언트 사이드 렌더링(CSR)**을 지원하는 환경을 제공하며, 정적 파일을 빠르게 로드하여 동적인 사용자 경험을 제공하는 데 중점을 두었습니다.

최신 웹 애플리케이션에서는 **서버 사이드 렌더링(SSR)**, **정적 사이트 생성(SSG)**, **인크리멘탈 정적 리젠레이션(ISR)**과 같은 다양한 렌더링 방식을 지원할 필요성이 대두되었습니다. Next.js와 같은 프레임워크들은 이러한 렌더링 방식을 모두 지원하며, 다양한 애플리케이션 아키텍처를 제공하는 동시에 성능 최적화와 SEO 문제를 해결했습니다.

CSR만으로는 **검색 엔진 최적화(SEO)**와 초기 로딩 시간에서 한계가 있었습니다. 특히 대규모 애플리케이션에서는 **빠른 첫 화면 렌더링(FCP)**이 중요한 성능 지표로 부각되었습니다. SSR은 서버에서 HTML을 미리 렌더링하여 브라우저에 전달하고, 이를 통해 초기 로딩 속도를 대폭 개선할 수 있었습니다. 그러나 CRA는 CSR 기반의 프레임워크로, 이러한 요구사항을 아무리 추가적인 설정을 하더라도 제대로 대응하기 어려웠습니다.

이러한 흐름 속에서 Next.js와 같은 **SSR을 기본으로 지원하는 프레임워크**들이 빠르게 인기를 끌게 되었습니다. 빠른 렌더링과 SEO 최적화를 동시에 달성할 수 있었고, 정적 사이트 생성(SSG) 기능은 SEO와 로딩 성능을 동시에 해결할 수 있어 CRA가 대체할 수 없는 강력한 모던 웹 애플리케이션의 요구를 충족시켰습니다.

결국 CRA는 이러한 모던 웹 애플리케이션의 발전에 대한 요구를 충분히 만족시키지 못하면서 서서히 대체되었고, 다른 새로운 도구들이 프론트엔드 개발에서 주류로 자리 잡게 되었습니다.

## 5. Vite의 등장

2020년, **Vite**라는 도구가 등장하면서 프론트엔드 개발의 패러다임은 또 한 번 큰 전환점을 맞았습니다. Vite는 특히 빠른 빌드 속도와 개발 서버의 효율성에서 큰 주목을 받으며 기존의 CRA와 비교되는 중요한 구심점을 제공했습니다. Vite는 단순 빌드 도구로서의 성능뿐만 아니라 모던 웹 애플리케이션을 구축하는 데 있어 더 나은 개발자 경험과 최적화된 프로덕션 빌드를 제공하려는 철학을 중심으로 설계되었습니다. 이 변화는 CRA의 한계를 보완하는 동시에, 새로운 프론트엔드 개발 환경을 제시하는 중요한 이정표가 되었습니다.

### 1) Vite의 탄생과 배경

Vite는 **Evan You**(Vue.js의 창시자)가 개발했습니다.
Vite의 주요 목표는 빠른 빌드 시간과 최소한의 설정으로 강력한 개발 경험을 제공하는 것이었습니다. 기존의 웹 개발 도구들이 매우 복잡한 설정과 느린 빌드 시간으로 인해 개발자들에게 불편함을 주고 있다는 문제의식을 바탕으로, Vite는 즉시 빌드와 **빠른 HMR(Hot Module Replacement)**을 구현하여 개발자들이 더 빠르게 피드백을 얻고, 생산성을 높일 수 있도록 만들었습니다.

Vite의 핵심적인 차별점은 **ES 모듈(ESM, ECMAScript Modules)을 기반으로 하는 점**입니다. ESM을 활용하면, 브라우저에서 모듈을 실시간으로 로드할 수 있기 때문에 번들링 과정을 생략할 수 있습니다. 이는 CRA와 같은 기존 도구들이 Webpack을 사용해 모든 코드를 번들링하는 방식과 큰 차이를 보였습니다.

Vite는 개발 중에는 실시간 모듈 로딩을 통해 빠르게 파일을 업데이트하고, 프로덕션 빌드 시에만 최적화된 번들링을 진행합니다. 이러한 방식이 개발 속도를 현저히 향상시켰고, 특히 대규모 애플리케이션에서 성능 향상의 큰 차이를 가져왔습니다.

### 2) Vite vs. CRA: 빌드 및 성능 차이

CRA는 Webpack을 사용하여 애플리케이션을 번들링하고, 모든 의존성을 한 번에 처리하는 방식입니다. 이 방식은 초기에는 괜찮았지만, 애플리케이션의 규모가 커지면 번들 크기가 커지고, 이로 인해 빌드 시간이 길어지며, 개발 서버의 응답 속도가 느려지기 시작합니다. Webpack의 복잡한 설정과 빌드 프로세스는 특히 대규모 애플리케이션에서 더욱 뚜렷하게 나타났고, 이를 해결하려면 세밀한 최적화 작업이 필요했습니다. 하지만 CRA는 이를 간단하게 설정하고 시작할 수 있도록 도와주는 도구였기 때문에, 복잡한 최적화가 필요한 대규모 프로젝트에는 한계를 지닌 도구였습니다.

반면 Vite는 개발 중에 **실시간 모듈 로딩(ESM)**을 사용하여 필요한 파일만 빠르게 로드하고, 개발 서버의 반응 속도를 극대화합니다. Webpack을 사용한 CRA와 달리, Vite는 번들링 없이 파일을 로드하므로, 빠른 빌드 속도와 즉시 피드백을 제공할 수 있습니다. 이는 개발자가 변경 사항을 즉시 확인하고 실시간으로 빠르게 피드백을 받을 수 있는 환경을 제공합니다. 대규모 애플리케이션에서 빌드 시간이 길어지는 문제를 해결하려면, Vite는 불필요한 번들링을 제거하고, 최소한의 설정으로 빠르게 작업을 진행할 수 있는 환경을 만들어줍니다.

Vite는 HMR(Hot Module Replacement) 속도에서 CRA보다 월등히 빠릅니다. CRA는 전체 애플리케이션을 다시 번들링해야 하는 과정에서 속도가 느려지고, 특히 큰 애플리케이션에서는 개발 서버의 반응이 느려질 수밖에 없습니다.

Vite는 파일을 모듈 단위로 빠르게 업데이트하고, 즉각적인 피드백을 제공하여 개발자가 작업하는 데 있어 효율성을 크게 높였습니다. 이러한 점에서 Vite는 빠른 빌드 속도와 신속한 피드백을 제공하는 도구로 자리 잡았습니다.

### 3) 커스터마이징과 확장성

Vite는 기본적으로 간단한 설정으로 시작할 수 있으며, 필요한 경우에는 플러그인을 통해 다양한 확장을 지원합니다. CRA는 eject 명령어를 통해 Webpack 설정을 직접 관리할 수 있게 했지만, 이로 인해 설정 복잡도가 증가하고 유지보수가 어려워졌습니다.

반면 Vite는 기본적으로 매우 간단하고 직관적인 설정을 제공하며, 필요할 때 플러그인과 설정을 통해 확장이 가능합니다. 또한, Vite는 모던 프레임워크와의 통합을 지원하여, Vue, React, Preact, Svelte 등 다양한 프레임워크와 쉽게 연동할 수 있습니다.

Vite의 유연성은 프로젝트의 크기나 요구 사항에 맞게 최적화된 설정을 제공할 수 있게 해줍니다. TypeScript나 ESLint, PostCSS 등과 같은 개발 도구와의 통합 등 프로젝트 규모가 커지더라도 효율적인 커스터마이징이 가능합니다. 이는 CRA가 ‘eject’ 이후의 복잡한 설정 관리로 인해 발생한 문제를 해결하며 개발자가 더 이상 불필요한 번거로움 없이 필요한 기능을 추가할 수 있는 환경을 제공했습니다.

> 사실 가장 중요한 것은, 무엇보다 속도의 차이였습니다. CRA는 너무 느립니다!

## 6. Meta의 CRA 지원중단, 그리고 deprecated 선언

이러한 배경 속에서 2023년 Meta는 CRA에 대한 지원 중단을 발표했고, 지난 2월 CRA를 deprecated 한다는 공식 발표를 하게 되었습니다. 현재 기준 React 공식 홈페이지에는 CRA에 대한 내용은 전혀 찾아볼 수 없습니다. Vite 또한 마찬가지입니다. React 공식 홈페이지에서는 Next.js, Remix, Expo 등의 프레임워크를 사용하길 권장하고 있는데, 이는 각 도구들이 제공하는 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), API 라우팅 등의 기능들이 웹 애플리케이션 개발에 중요한 요소로 자리잡았기 때문입니다. CRA는 본래 클라이언트 사이드 렌더링(CSR) 중심의 앱을 빠르게 구축할 수 있는 도구로 시작했지만, 시간이 흐르면서 모던 웹 애플리케이션에서 요구되는 다양한 기능 확장성과 최적화에 대응하기 어려운 구조로 변질되었기 때문입니다.

React 팀이 CRA 대신 Next.js와 Remix를 추천하는 이유는, 이들 프레임워크가 SEO 최적화와 성능 향상에 강력한 기능을 제공하고, React 애플리케이션의 유연성을 극대화할 수 있기 때문입니다. Next.js는 SSR과 SSG를 기본적으로 지원하며, 파일 시스템 기반 라우팅과 같은 유용한 기능들 덕분에 복잡한 애플리케이션을 효율적으로 관리할 수 있습니다. Remix는 데이터 페칭과 라우팅을 보다 효율적이고 유연하게 처리할 수 있어, 더욱 복잡한 사용자 경험을 요구하는 웹 애플리케이션에 유리한 구조를 제공합니다. 한편, Expo는 React Native 기반의 모바일 애플리케이션을 개발하는 데 강력한 도구로 자리잡고 있으며, 크로스 플랫폼 개발에 최적화된 기능을 제공합니다.

이와 같이 Vite, Next.js, Remix 등은 단순히 프론트엔드 빌드 도구로서의 역할을 넘어서, 풀스택 개발을 위한 종합적인 솔루션을 제공하고 있습니다. 이러한 툴들은 빌드 속도와 개발자 경험을 크게 향상시킬 뿐만 아니라, 모던 웹 개발에서 중요한 성능 최적화, SEO 개선, 서버 사이드 기능 등을 지원하면서, 기존 CRA가 해결하지 못했던 부분들을 완벽히 보완하고 있습니다.

CRA가 deprecated되었을 뿐만 아니라, Meta와 React 커뮤니티는 Vite와 같은 도구들을 사용하여 더욱 효율적이고 고성능의 웹 애플리케이션을 구축할 수 있는 방향으로 전환하고 있습니다. Vite의 등장으로 빠른 개발 속도와 효율적인 프로덕션 빌드를 제공하면서, **클라이언트 사이드 렌더링(CSR)**의 한계를 뛰어넘는 모던 프론트엔드 개발 환경을 제공하는 데 중점을 두고 있습니다. **ESM(ECMAScript Modules)**을 활용한 모듈 기반의 접근 방식은 실시간 코드 수정과 빠른 빌드 시간을 가능하게 해줍니다. 또한, Vite는 Next.js와 Remix와 함께, 빠른 속도와 성능 최적화가 중요한 웹 애플리케이션에서 기본적으로 제공해야 할 기능들을 모두 충족할 수 있습니다.

결국, CRA는 자신의 역할을 다했지만 기술 발전과 커뮤니티의 요구에 맞춰 새로운 대체 도구들이 등장하면서 역사 속으로 사라지게 되었습니다. React 커뮤니티의 지속적인 발전과 모던 웹 애플리케이션의 요구에 맞춰, 새로운 개발 도구는 더 이상 단순한 번들링 도구에 그치지 않고, 다양한 기능을 포괄하는 풀스택 개발의 필요성을 충족하는 방향으로 진화하고 있습니다. 이러한 변화는 프론트엔드 개발의 패러다임을 새롭게 정의하며, 개발자들이 더 빠르고 효율적인 웹 애플리케이션을 구축할 수 있도록 돕고 있습니다.

이제는 Vite, Next.js, Remix와 같은 도구들이 프론트엔드 개발의 중심에 서게 되었고, 이들 도구들이 제공하는 기능과 성능 최적화는 향후 몇 년 간 모던 웹 개발의 표준이 될 것이라 생각합니다. CRA의 퇴장은 프론트엔드 도구의 발전 과정에서 중요한 전환점을 의미하며, 기술 혁신과 개발자 경험을 우선시하는 새로운 웹 개발 환경의 시작으로 도약합니다.
