# 페이지네이션

- 많은 데이터를 여러 개의 페이지로 나누어 표시하는 기법
- 한 번에 모든 데이터를 불러오지 않고 필요한 만큼만 로드하여 성능을 최적화홤
- 예시: 게시판, 쇼핑몰 상품 목록, 블로그 글 목록 등

## 페이지네이션의 필요성

### ✅ 1. 데이터 로딩 최적화

- 한 번에 많은 데이터를 불러오면 속도가 느려질 수 있음
- 페이지별로 데이터를 나누어 가져오면 불필요한 데이터 로딩을 방지할 수 있음

### ✅ 2. 사용자 경험(UX) 향상

- 한 화면에 너무 많은 정보가 표시되면 가독성이 떨어짐
- 필요한 정보만 적절히 보여주면 사용자가 더 쉽게 탐색할 수 있음

### ✅ 3. 서버 부담 감소

- 필요한 데이터만 요청하므로 서버 부하를 줄일 수 있음
- 특히 데이터가 많아질수록 성능 최적화에 중요한 역할을 함

## 페이지네이션 구현 방식

### 1. Offset 기반

- 특정 페이지를 요청할 때 시작 위치(Offset) 와 보여줄 개수(Limit) 를 지정하는 방식

```http
GET https://example.com/posts?offset=20&limit10
```

→ **지금까지 20개 받았고, 10개 더 보내줘.**

✅ 간단하고 구현이 쉬움
✅ 특정 페이지로 이동 가능

🚨 데이터 양이 많아질수록 OFFSET이 클 경우 속도가 느려짐
🚨 데이터가 추가/삭제될 경우 순서가 꼬일 가능성이 있음

#### SQL 예제

```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 20;
```

→ 최신 글을 10개 가져오되, 20개를 건너뛰고 가져옴.

### 2. Cursor 기반

- 데이터를 식별할 수 있는 **고유 키(cursor)** 를 기반으로 페이지를 구분하는 방식

```http
GET https://example.com/posts?cursor=WerZxc&limit10
```

→ **“커서 WerZxc 이후 데이터 10개 더 보내줘.”**

✅ 데이터 추가/삭제가 되어도 순서가 꼬이지 않음.

✅ OFFSET을 사용할 때보다 속도가 빠름(특히 대량 데이터 처리 시 유리).

🚨 특정 페이지로 바로 이동이 어려움.

🚨 백엔드에서 구현이 상대적으로 까다로울 수 있음.

#### SQL 예제

```sql
SELECT * FROM posts WHERE id > 50 ORDER BY id ASC LIMIT 10;
```

→ id > 50인 데이터부터 10개 가져오기.

## 언제 어떤 방식을 써야 할까?

✅ 데이터가 많지 않고, 특정 페이지 이동이 필요하다면? → **Offset 방식**

✅ 데이터가 많고, 실시간으로 변경된다면? → **Cursor 방식**
